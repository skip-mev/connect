// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: slinky/alerts/v1/alerts.proto

package types

import (
	fmt "fmt"
	types1 "github.com/cometbft/cometbft/abci/types"
	_ "github.com/cosmos/cosmos-proto"
	types2 "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/skip-mev/slinky/x/oracle/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Alert defines the basic meta-data necessary for the alerts module to resolve
// a claim that the price of a CurrencyPair on-chain is deviating from the price
// off-chain.
type Alert struct {
	// height represents the height for which the alert is filed.
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// signer is the signer of this alert, this is the address that will receive
	// the reward in the case of a positive conclusion, or whose bond will get
	// slashed in the event of a negative conclusion.
	Signer string `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	// currency_pair is the currency-pair that this claim asserts is deviating
	// from the price off-chain.
	CurrencyPair types.CurrencyPair `protobuf:"bytes,3,opt,name=currency_pair,json=currencyPair,proto3" json:"currency_pair"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}
func (*Alert) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{0}
}
func (m *Alert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert.Merge(m, src)
}
func (m *Alert) XXX_Size() int {
	return m.Size()
}
func (m *Alert) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert.DiscardUnknown(m)
}

var xxx_messageInfo_Alert proto.InternalMessageInfo

func (m *Alert) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Alert) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *Alert) GetCurrencyPair() types.CurrencyPair {
	if m != nil {
		return m.CurrencyPair
	}
	return types.CurrencyPair{}
}

// AlertStatus contains the module specific state for an alert: Has the alert
// been concluded? What height was the alert submitted, what height should the
// alert be purged?
type AlertStatus struct {
	// ConclusionStatus determines whether the alert has been concluded.
	ConclusionStatus uint64 `protobuf:"varint,1,opt,name=conclusion_status,json=conclusionStatus,proto3" json:"conclusion_status,omitempty"`
	// SubmissionHeight is the height that the alert was submitted in.
	SubmissionHeight uint64 `protobuf:"varint,2,opt,name=submission_height,json=submissionHeight,proto3" json:"submission_height,omitempty"`
	// SubmissionTimestamp is the block-timestamp of the block that the alert was
	// submitted in (as a UTC value in Unix time).
	SubmissionTimestamp uint64 `protobuf:"varint,3,opt,name=submission_timestamp,json=submissionTimestamp,proto3" json:"submission_timestamp,omitempty"`
	// PurgeHeight is the height at which the alert should be purged.
	PurgeHeight uint64 `protobuf:"varint,4,opt,name=purge_height,json=purgeHeight,proto3" json:"purge_height,omitempty"`
}

func (m *AlertStatus) Reset()         { *m = AlertStatus{} }
func (m *AlertStatus) String() string { return proto.CompactTextString(m) }
func (*AlertStatus) ProtoMessage()    {}
func (*AlertStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{1}
}
func (m *AlertStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertStatus.Merge(m, src)
}
func (m *AlertStatus) XXX_Size() int {
	return m.Size()
}
func (m *AlertStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AlertStatus proto.InternalMessageInfo

func (m *AlertStatus) GetConclusionStatus() uint64 {
	if m != nil {
		return m.ConclusionStatus
	}
	return 0
}

func (m *AlertStatus) GetSubmissionHeight() uint64 {
	if m != nil {
		return m.SubmissionHeight
	}
	return 0
}

func (m *AlertStatus) GetSubmissionTimestamp() uint64 {
	if m != nil {
		return m.SubmissionTimestamp
	}
	return 0
}

func (m *AlertStatus) GetPurgeHeight() uint64 {
	if m != nil {
		return m.PurgeHeight
	}
	return 0
}

// AlertWithStatus represents a wrapper around the Alert and AlertStatus
// objects, this is so that the module specific information about Alerts can be
// packaged together.
type AlertWithStatus struct {
	// alert is the alert that this status corresponds to.
	Alert Alert `protobuf:"bytes,1,opt,name=alert,proto3" json:"alert"`
	// status is the status of the alert.
	Status AlertStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status"`
}

func (m *AlertWithStatus) Reset()         { *m = AlertWithStatus{} }
func (m *AlertWithStatus) String() string { return proto.CompactTextString(m) }
func (*AlertWithStatus) ProtoMessage()    {}
func (*AlertWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{2}
}
func (m *AlertWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertWithStatus.Merge(m, src)
}
func (m *AlertWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *AlertWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AlertWithStatus proto.InternalMessageInfo

func (m *AlertWithStatus) GetAlert() Alert {
	if m != nil {
		return m.Alert
	}
	return Alert{}
}

func (m *AlertWithStatus) GetStatus() AlertStatus {
	if m != nil {
		return m.Status
	}
	return AlertStatus{}
}

// Signature is a container for a signer address mapped to a signature.
type Signature struct {
	Signer    string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{3}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MultiSigConcluson defines a conclusion that is accompanied by a set of
// signatures. The signature is defined over the alert UID, status, OracleData,
// and PriceBound. The signatures are used to verify that the conclusion is
// valid.
type MultiSigConclusion struct {
	// alert is the alert that this conclusion corresponds to.
	Alert Alert `protobuf:"bytes,1,opt,name=alert,proto3" json:"alert"`
	// oracle_data is the oracle data that this conclusion references.
	ExtendedCommitInfo types1.ExtendedCommitInfo `protobuf:"bytes,2,opt,name=extended_commit_info,json=extendedCommitInfo,proto3" json:"extended_commit_info"`
	// signatures is a map of signer -> signature. Where the signature is over
	// Alert.UID, PriceBound, the marshalled ExtendedCommitInfo, and status.
	Signatures []Signature `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures"`
	// price-bound is the price bound of the currency-pair off-chain for the
	// designated time-range.
	PriceBound PriceBound `protobuf:"bytes,4,opt,name=price_bound,json=priceBound,proto3" json:"price_bound"`
	// status is the status of the conclusion.
	Status bool `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
	// CurrencyPairID is the Ticker of the currency-pair that this conclusion
	// corresponds to.
	CurrencyPairID uint64 `protobuf:"varint,6,opt,name=currency_pair_i_d,json=currencyPairID,proto3" json:"currency_pair_i_d,omitempty"`
}

func (m *MultiSigConclusion) Reset()         { *m = MultiSigConclusion{} }
func (m *MultiSigConclusion) String() string { return proto.CompactTextString(m) }
func (*MultiSigConclusion) ProtoMessage()    {}
func (*MultiSigConclusion) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{4}
}
func (m *MultiSigConclusion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiSigConclusion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiSigConclusion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiSigConclusion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiSigConclusion.Merge(m, src)
}
func (m *MultiSigConclusion) XXX_Size() int {
	return m.Size()
}
func (m *MultiSigConclusion) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiSigConclusion.DiscardUnknown(m)
}

var xxx_messageInfo_MultiSigConclusion proto.InternalMessageInfo

func (m *MultiSigConclusion) GetAlert() Alert {
	if m != nil {
		return m.Alert
	}
	return Alert{}
}

func (m *MultiSigConclusion) GetExtendedCommitInfo() types1.ExtendedCommitInfo {
	if m != nil {
		return m.ExtendedCommitInfo
	}
	return types1.ExtendedCommitInfo{}
}

func (m *MultiSigConclusion) GetSignatures() []Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *MultiSigConclusion) GetPriceBound() PriceBound {
	if m != nil {
		return m.PriceBound
	}
	return PriceBound{}
}

func (m *MultiSigConclusion) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *MultiSigConclusion) GetCurrencyPairID() uint64 {
	if m != nil {
		return m.CurrencyPairID
	}
	return 0
}

// MultiSigConclusionVerificationParams defines the parameters necessary to
// verify a MultiSigConclusion. It contains a map between signer and public key.
// Notice, the public-key (value) are the base-64 encoded bytes of the public
// key. And the signer (key) is the bech32 encoded address of the signer.
// Notice, all public keys must be secp256 keys.
type MultiSigConclusionVerificationParams struct {
	// signers is a map of signer -> public key.
	Signers []*types2.Any `protobuf:"bytes,1,rep,name=signers,proto3" json:"signers,omitempty"`
}

func (m *MultiSigConclusionVerificationParams) Reset()         { *m = MultiSigConclusionVerificationParams{} }
func (m *MultiSigConclusionVerificationParams) String() string { return proto.CompactTextString(m) }
func (*MultiSigConclusionVerificationParams) ProtoMessage()    {}
func (*MultiSigConclusionVerificationParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{5}
}
func (m *MultiSigConclusionVerificationParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiSigConclusionVerificationParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiSigConclusionVerificationParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiSigConclusionVerificationParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiSigConclusionVerificationParams.Merge(m, src)
}
func (m *MultiSigConclusionVerificationParams) XXX_Size() int {
	return m.Size()
}
func (m *MultiSigConclusionVerificationParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiSigConclusionVerificationParams.DiscardUnknown(m)
}

var xxx_messageInfo_MultiSigConclusionVerificationParams proto.InternalMessageInfo

func (m *MultiSigConclusionVerificationParams) GetSigners() []*types2.Any {
	if m != nil {
		return m.Signers
	}
	return nil
}

// PriceBound represents the bounds of the price of a currency-pair off chain
// for a designated time-range
type PriceBound struct {
	High string `protobuf:"bytes,1,opt,name=high,proto3" json:"high,omitempty"`
	Low  string `protobuf:"bytes,2,opt,name=low,proto3" json:"low,omitempty"`
}

func (m *PriceBound) Reset()         { *m = PriceBound{} }
func (m *PriceBound) String() string { return proto.CompactTextString(m) }
func (*PriceBound) ProtoMessage()    {}
func (*PriceBound) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfa72dab4ea7298e, []int{6}
}
func (m *PriceBound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceBound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceBound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceBound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceBound.Merge(m, src)
}
func (m *PriceBound) XXX_Size() int {
	return m.Size()
}
func (m *PriceBound) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceBound.DiscardUnknown(m)
}

var xxx_messageInfo_PriceBound proto.InternalMessageInfo

func (m *PriceBound) GetHigh() string {
	if m != nil {
		return m.High
	}
	return ""
}

func (m *PriceBound) GetLow() string {
	if m != nil {
		return m.Low
	}
	return ""
}

func init() {
	proto.RegisterType((*Alert)(nil), "slinky.alerts.v1.Alert")
	proto.RegisterType((*AlertStatus)(nil), "slinky.alerts.v1.AlertStatus")
	proto.RegisterType((*AlertWithStatus)(nil), "slinky.alerts.v1.AlertWithStatus")
	proto.RegisterType((*Signature)(nil), "slinky.alerts.v1.Signature")
	proto.RegisterType((*MultiSigConclusion)(nil), "slinky.alerts.v1.MultiSigConclusion")
	proto.RegisterType((*MultiSigConclusionVerificationParams)(nil), "slinky.alerts.v1.MultiSigConclusionVerificationParams")
	proto.RegisterType((*PriceBound)(nil), "slinky.alerts.v1.PriceBound")
}

func init() { proto.RegisterFile("slinky/alerts/v1/alerts.proto", fileDescriptor_dfa72dab4ea7298e) }

var fileDescriptor_dfa72dab4ea7298e = []byte{
	// 782 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x41, 0x6f, 0xd3, 0x48,
	0x14, 0x8e, 0x9b, 0x34, 0xbb, 0x99, 0x74, 0x77, 0xdb, 0xd9, 0xec, 0x6e, 0x9a, 0xb4, 0x6e, 0x36,
	0xdb, 0x43, 0xba, 0x10, 0x9b, 0xa4, 0xb7, 0x20, 0x21, 0x25, 0x01, 0x89, 0x1e, 0x90, 0xaa, 0x04,
	0x81, 0x04, 0x07, 0xcb, 0x71, 0x26, 0xce, 0xa8, 0xf1, 0x8c, 0x35, 0x33, 0x0e, 0xcd, 0x5f, 0xe0,
	0xc4, 0xdf, 0xe0, 0x06, 0x52, 0x0f, 0x88, 0x5f, 0x50, 0xf5, 0x54, 0x71, 0xe2, 0x04, 0xa8, 0x3d,
	0xf0, 0x37, 0x90, 0xc7, 0xe3, 0x38, 0x34, 0x2d, 0x07, 0x2e, 0xd6, 0xcc, 0x7b, 0xdf, 0x7b, 0xfe,
	0xde, 0xf7, 0xde, 0x1b, 0xb0, 0xcd, 0x27, 0x98, 0x1c, 0xcd, 0x4c, 0x7b, 0x82, 0x98, 0xe0, 0xe6,
	0xb4, 0xa1, 0x4e, 0x86, 0xcf, 0xa8, 0xa0, 0x70, 0x3d, 0x72, 0x1b, 0xca, 0x38, 0x6d, 0x94, 0x74,
	0x15, 0x40, 0x99, 0xed, 0x4c, 0x50, 0x18, 0xe0, 0x22, 0x82, 0x38, 0x56, 0x11, 0xa5, 0x0d, 0xdb,
	0xc3, 0x84, 0x9a, 0xf2, 0xab, 0x4c, 0x9b, 0x0e, 0xe5, 0x1e, 0xe5, 0x96, 0xbc, 0x99, 0xd1, 0x45,
	0xb9, 0x0a, 0x2e, 0x75, 0x69, 0x64, 0x0f, 0x4f, 0xca, 0x5a, 0x16, 0x88, 0x0c, 0x11, 0xf3, 0x30,
	0x11, 0xa6, 0x3d, 0x70, 0xb0, 0x29, 0x66, 0x3e, 0x8a, 0x43, 0x36, 0x5d, 0x4a, 0xdd, 0x09, 0x32,
	0xe5, 0x6d, 0x10, 0x8c, 0x4c, 0x9b, 0xcc, 0x22, 0x57, 0xf5, 0x9d, 0x06, 0x56, 0xdb, 0x21, 0x53,
	0xf8, 0x37, 0xc8, 0x8e, 0x11, 0x76, 0xc7, 0xa2, 0xa8, 0x55, 0xb4, 0x5a, 0xa6, 0xa7, 0x6e, 0xf0,
	0x0e, 0xc8, 0x72, 0xec, 0x12, 0xc4, 0x8a, 0x2b, 0x15, 0xad, 0x96, 0xeb, 0x14, 0x3f, 0x9c, 0xd4,
	0x0b, 0x8a, 0x51, 0x7b, 0x38, 0x64, 0x88, 0xf3, 0xbe, 0x60, 0x98, 0xb8, 0x3d, 0x85, 0x83, 0x07,
	0xe0, 0x37, 0x27, 0x60, 0x0c, 0x11, 0x67, 0x66, 0xf9, 0x36, 0x66, 0xc5, 0x74, 0x45, 0xab, 0xe5,
	0x9b, 0xba, 0xa1, 0x94, 0x89, 0x74, 0x30, 0xa6, 0x0d, 0xa3, 0xab, 0x60, 0x87, 0x36, 0x66, 0x9d,
	0xcc, 0xe9, 0xa7, 0x9d, 0x54, 0x6f, 0xcd, 0x59, 0xb0, 0xb5, 0x4a, 0x2f, 0xbf, 0xbe, 0xf9, 0xff,
	0x2f, 0xa5, 0xdf, 0x71, 0x2c, 0xb9, 0x24, 0x5c, 0xfd, 0xac, 0x81, 0xbc, 0x3c, 0xf5, 0x85, 0x2d,
	0x02, 0x0e, 0x6f, 0x81, 0x0d, 0x87, 0x12, 0x67, 0x12, 0x70, 0x4c, 0x89, 0xc5, 0xa5, 0x51, 0xd5,
	0xb2, 0x9e, 0x38, 0x12, 0x30, 0x0f, 0x06, 0x1e, 0xe6, 0x12, 0xac, 0x0a, 0x5f, 0x89, 0xc0, 0x89,
	0xe3, 0x61, 0x24, 0x41, 0x03, 0x14, 0x16, 0xc0, 0x02, 0x7b, 0x88, 0x0b, 0xdb, 0xf3, 0x65, 0x5d,
	0x99, 0xde, 0x9f, 0x89, 0xef, 0x71, 0xec, 0x82, 0xff, 0x82, 0x35, 0x3f, 0x60, 0x2e, 0x8a, 0x53,
	0x67, 0x24, 0x34, 0x2f, 0x6d, 0x51, 0xd6, 0x56, 0x25, 0xac, 0xad, 0x7c, 0x6d, 0x6d, 0x11, 0xc9,
	0xea, 0x6b, 0x0d, 0xfc, 0x21, 0xef, 0x4f, 0xb1, 0x18, 0x2b, 0xe2, 0xfb, 0x60, 0x55, 0x22, 0x65,
	0x65, 0xf9, 0xe6, 0x3f, 0xc6, 0xd5, 0x71, 0x33, 0x64, 0x84, 0x52, 0x33, 0xc2, 0xc2, 0xbb, 0x20,
	0xab, 0xf4, 0x58, 0x91, 0x51, 0xdb, 0x37, 0x44, 0x45, 0xff, 0x50, 0xb1, 0x2a, 0xa4, 0xb5, 0x1b,
	0xf2, 0xdc, 0xb9, 0x96, 0x67, 0xc2, 0xab, 0xda, 0x06, 0xb9, 0x3e, 0x76, 0x89, 0x2d, 0x02, 0x86,
	0xc2, 0x59, 0x52, 0x33, 0x13, 0xb2, 0xcc, 0xcd, 0x27, 0x63, 0x0b, 0xe4, 0x78, 0x0c, 0x92, 0x54,
	0xd6, 0x7a, 0x89, 0xa1, 0xfa, 0x36, 0x0d, 0xe0, 0xa3, 0x60, 0x22, 0x70, 0x1f, 0xbb, 0xdd, 0x79,
	0xc3, 0x7e, 0xae, 0xe2, 0xe7, 0xa0, 0x80, 0x8e, 0xe5, 0x4e, 0x0c, 0x2d, 0x87, 0x7a, 0x1e, 0x16,
	0x16, 0x26, 0x23, 0xaa, 0xea, 0xff, 0xcf, 0x48, 0xd6, 0xc5, 0x08, 0xd7, 0xc5, 0x78, 0xa0, 0xc0,
	0x5d, 0x89, 0x3d, 0x20, 0x23, 0xaa, 0xf2, 0x41, 0xb4, 0xe4, 0x81, 0x6d, 0x00, 0xe6, 0xac, 0x79,
	0x31, 0x5d, 0x49, 0xd7, 0xf2, 0xcd, 0xf2, 0x32, 0xad, 0xb9, 0x1e, 0x2a, 0xd5, 0x42, 0x10, 0xec,
	0x82, 0xbc, 0xcf, 0xb0, 0x83, 0xac, 0x01, 0x0d, 0xc8, 0x50, 0x8e, 0x47, 0xbe, 0xb9, 0xb5, 0x9c,
	0xe3, 0x30, 0x04, 0x75, 0x42, 0x4c, 0x9c, 0xc4, 0x9f, 0x5b, 0xa4, 0xcc, 0x51, 0x5b, 0x57, 0x2b,
	0x5a, 0xed, 0xd7, 0xb8, 0x63, 0x70, 0x0f, 0x6c, 0x7c, 0xb7, 0x80, 0x16, 0xb6, 0x86, 0xc5, 0xac,
	0x9c, 0xc0, 0xdf, 0x17, 0xd7, 0xeb, 0xe0, 0x7e, 0xeb, 0xde, 0xd9, 0x49, 0xbd, 0xbc, 0xf4, 0xd7,
	0x44, 0xfd, 0xb0, 0xf7, 0xa5, 0xab, 0xbd, 0x4f, 0xdc, 0xd5, 0xf7, 0x1a, 0xd8, 0x5d, 0xee, 0xd9,
	0x13, 0xc4, 0xf0, 0x08, 0x3b, 0xb6, 0xc0, 0x94, 0x1c, 0xda, 0xcc, 0xf6, 0x38, 0x34, 0xc0, 0x2f,
	0xd1, 0x10, 0x84, 0x3b, 0x19, 0x0a, 0x56, 0x30, 0xa2, 0x57, 0xc9, 0x88, 0x5f, 0x25, 0xa3, 0x4d,
	0x66, 0xbd, 0x18, 0xd4, 0x1a, 0x9c, 0x9d, 0xd4, 0xeb, 0x3f, 0x20, 0xb6, 0xfc, 0x8b, 0x90, 0xea,
	0xed, 0x9b, 0xa9, 0x2e, 0x07, 0x54, 0x9b, 0x00, 0x24, 0xfa, 0x42, 0x08, 0x32, 0x63, 0xec, 0x8e,
	0xd5, 0xc8, 0xca, 0x33, 0x5c, 0x07, 0xe9, 0x09, 0x7d, 0x11, 0xbd, 0x7c, 0xbd, 0xf0, 0xd8, 0xe9,
	0x9e, 0x5e, 0xe8, 0xda, 0xf9, 0x85, 0xae, 0x7d, 0xb9, 0xd0, 0xb5, 0x57, 0x97, 0x7a, 0xea, 0xfc,
	0x52, 0x4f, 0x7d, 0xbc, 0xd4, 0x53, 0xcf, 0xf6, 0x5c, 0x2c, 0xc6, 0xc1, 0xc0, 0x70, 0xa8, 0x67,
	0xf2, 0x23, 0xec, 0xd7, 0x3d, 0x34, 0x35, 0xaf, 0xf2, 0x91, 0xcf, 0xf2, 0x20, 0x2b, 0x6b, 0xde,
	0xff, 0x16, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xb1, 0xac, 0x7e, 0x4b, 0x06, 0x00, 0x00,
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CurrencyPair.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlerts(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintAlerts(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlertStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PurgeHeight != 0 {
		i = encodeVarintAlerts(dAtA, i, uint64(m.PurgeHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.SubmissionTimestamp != 0 {
		i = encodeVarintAlerts(dAtA, i, uint64(m.SubmissionTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.SubmissionHeight != 0 {
		i = encodeVarintAlerts(dAtA, i, uint64(m.SubmissionHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.ConclusionStatus != 0 {
		i = encodeVarintAlerts(dAtA, i, uint64(m.ConclusionStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlertWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlerts(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Alert.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlerts(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiSigConclusion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiSigConclusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiSigConclusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrencyPairID != 0 {
		i = encodeVarintAlerts(dAtA, i, uint64(m.CurrencyPairID))
		i--
		dAtA[i] = 0x30
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.PriceBound.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlerts(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlerts(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.ExtendedCommitInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlerts(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Alert.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlerts(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MultiSigConclusionVerificationParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiSigConclusionVerificationParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiSigConclusionVerificationParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlerts(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PriceBound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceBound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceBound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Low) > 0 {
		i -= len(m.Low)
		copy(dAtA[i:], m.Low)
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Low)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.High) > 0 {
		i -= len(m.High)
		copy(dAtA[i:], m.High)
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.High)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAlerts(dAtA []byte, offset int, v uint64) int {
	offset -= sovAlerts(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovAlerts(uint64(m.Height))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.CurrencyPair.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConclusionStatus != 0 {
		n += 1 + sovAlerts(uint64(m.ConclusionStatus))
	}
	if m.SubmissionHeight != 0 {
		n += 1 + sovAlerts(uint64(m.SubmissionHeight))
	}
	if m.SubmissionTimestamp != 0 {
		n += 1 + sovAlerts(uint64(m.SubmissionTimestamp))
	}
	if m.PurgeHeight != 0 {
		n += 1 + sovAlerts(uint64(m.PurgeHeight))
	}
	return n
}

func (m *AlertWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Alert.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *MultiSigConclusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Alert.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ExtendedCommitInfo.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = m.PriceBound.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if m.Status {
		n += 2
	}
	if m.CurrencyPairID != 0 {
		n += 1 + sovAlerts(uint64(m.CurrencyPairID))
	}
	return n
}

func (m *MultiSigConclusionVerificationParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signers) > 0 {
		for _, e := range m.Signers {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *PriceBound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.High)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Low)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func sovAlerts(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAlerts(x uint64) (n int) {
	return sovAlerts(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrencyPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConclusionStatus", wireType)
			}
			m.ConclusionStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConclusionStatus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionHeight", wireType)
			}
			m.SubmissionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionTimestamp", wireType)
			}
			m.SubmissionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeHeight", wireType)
			}
			m.PurgeHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurgeHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Alert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiSigConclusion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiSigConclusion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiSigConclusion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Alert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedCommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExtendedCommitInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PriceBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyPairID", wireType)
			}
			m.CurrencyPairID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyPairID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiSigConclusionVerificationParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiSigConclusionVerificationParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiSigConclusionVerificationParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, &types2.Any{})
			if err := m.Signers[len(m.Signers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceBound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceBound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceBound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.High = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlerts
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Low = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlerts(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAlerts
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAlerts
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAlerts
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAlerts        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlerts          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAlerts = fmt.Errorf("proto: unexpected end of group")
)
